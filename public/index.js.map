{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["const NUM_RAYS = 15000;\nconst NUM_TRIANGLES = 3000;\nconst NUM_INTERSECTIONS = 20000;\n\n// 6 floats (x, y, z, dx, dy, dz).\nconst RAY_BUFFER_LENGTH = NUM_RAYS * 6;\nconst RAY_BUFFER_SIZE = RAY_BUFFER_LENGTH * 4; // bytes.\n\n// 9 floats (x1, y1, z1, x2, y2, z2, x3, y3, z3).\nconst TRIANGLE_BUFFER_LENGTH = NUM_TRIANGLES * 9;\nconst TRIANGLE_BUFFER_SIZE = TRIANGLE_BUFFER_LENGTH * 4; // bytes.\n\n// 1 float (distance).\nconst RESULT_BUFFER_LENGTH = NUM_RAYS * 1;\nconst RESULT_BUFFER_SIZE = RESULT_BUFFER_LENGTH * 4;\n\n// The advice from https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html\n// is to always use a workgroup size of 64, as this is what most GPUs are best at.\nconst WORKGROUP_SIZE = 64;\n\nfunction rand() {\n  return Math.random() * 2 - 1;\n}\n\n// Create the ray data.\nconst rayData = new Float32Array(RAY_BUFFER_LENGTH);\n\nfor (let i = 0; i < NUM_RAYS; ++i) {\n  const ind = i * 6;\n  rayData[ind + 0] = rand() * 100;\n  rayData[ind + 1] = rand() * 100;\n  rayData[ind + 2] = rand() * 100;\n\n  let dx = rand();\n  let dy = rand();\n  let dz = rand();\n  let n = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);\n\n  rayData[ind + 3] = dx / n;\n  rayData[ind + 4] = dy / n;\n  rayData[ind + 5] = dz / n;\n}\n\n// Create the triangle data.\nconst triangleData = new Float32Array(TRIANGLE_BUFFER_LENGTH);\n\nfor (let i = 0; i < NUM_TRIANGLES; ++i) {\n  const ind = i * 9;\n  triangleData[ind + 0] = rand() * 100;\n  triangleData[ind + 1] = rand() * 100;\n  triangleData[ind + 2] = rand() * 100;\n  triangleData[ind + 3] = rand() * 100;\n  triangleData[ind + 4] = rand() * 100;\n  triangleData[ind + 5] = rand() * 100;\n  triangleData[ind + 6] = rand() * 100;\n  triangleData[ind + 7] = rand() * 100;\n  triangleData[ind + 8] = rand() * 100;\n}\n\n// Define shader code.\nconst shader = /* wgsl */ `\n  struct Ray {\n    x: f32,\n    y: f32,\n    z: f32,\n    dx: f32,\n    dy: f32,\n    dz: f32,\n  }\n\n  struct Triangle {\n    x1: f32, y1: f32, z1: f32,\n    x2: f32, y2: f32, z2: f32,\n    x3: f32, y3: f32, z3: f32,\n  }\n\n  // TODO: can we remove read_write here.\n  @group(0) @binding(0)\n  var<storage, read_write> rayBuffer: array<Ray>;\n\n  @group(0) @binding(1)\n  var<storage, read_write> triangleBuffer: array<Triangle>;\n\n  @group(0) @binding(2)\n  var<storage, read_write> output: array<f32>;\n\n  @compute @workgroup_size(${WORKGROUP_SIZE})\n  fn main(\n    @builtin(global_invocation_id)\n    global_id : vec3u,\n  ) {\n    let index = global_id.x;\n\n    // Avoid accessing the buffer out of bounds - this could happen\n    // if NUM_RAYS and WORKGROUP_SIZE don't line up.\n    if (index >= ${NUM_RAYS}) {\n      return;\n    }\n\n    let ray = rayBuffer[index];\n\n    // This is more or less a line-by-line translation of the M\u00F6ller\u2013Trumbore intersection algorithm C++ example from Wikipedia.\n    // TODO: research triangle intersection algorithms to see if there are others - though this one seems to be really simple so\n    //       I doubt it can be improved much.\n    // TODO: currently the GPU is passed triangles as points (as in the example code), but it would be slightly faster to store them\n    //       instead as position + U + V.\n\n    let epsilon = 0.0000001; // TODO: find a principled value for this.\n\n    let raydirection = vec3f(ray.dx, ray.dy, ray.dz);\n\n    let triangleCount = i32(arrayLength(&triangleBuffer));\n\n    for (var n = 0; n < ${NUM_INTERSECTIONS}; n++) {\n      for (var i = 0; i < triangleCount; i++) {\n        let triangle = triangleBuffer[i];\n\n        // TODO: pass data as uv, not points.\n        let edge1 = vec3f(triangle.x2 - triangle.x1, triangle.y2 - triangle.y1, triangle.z2 - triangle.z1);\n        let edge2 = vec3f(triangle.x3 - triangle.x1, triangle.y3 - triangle.y1, triangle.z3 - triangle.z1);\n        let ray_cross_e2 = cross(raydirection, edge2);\n        let det = dot(edge1, ray_cross_e2);\n\n        if (det > -epsilon && det < epsilon) {\n          continue;\n        }\n\n        let inv_det = 1.0 / det;\n        let offset = vec3f(ray.x - triangle.x1, ray.y - triangle.y1, ray.z - triangle.z1);\n        let u = inv_det * dot(offset, ray_cross_e2);\n\n        if ((u < 0 && abs(u) > epsilon) || (u > 1 && abs(u-1) > epsilon)) {\n          continue;\n        }\n\n        let offset_cross_e1 = cross(offset, edge1);\n        let v = inv_det * dot(raydirection, offset_cross_e1);\n\n        if ((v < 0 && abs(v) > epsilon) || (u + v > 1 && abs(u+v-1) > epsilon)) {\n          continue;\n        }\n\n        let t = inv_det * dot(edge2, offset_cross_e1);\n\n        // TODO: initially set at infinity.\n        if (t > epsilon && (output[index] == 0 || t < output[index])) {\n          output[index] = t;\n        }\n      }\n    }\n  }\n`;\n\nasync function getGPUDevice(): Promise<GPUDevice | null> {\n  // Ensure that the browser supports the GPU API.\n  if (!navigator.gpu) {\n    alert(\"GPU/browser not supported\");\n    return null;\n  }\n\n  // Get the GPU adapter, from which a GPU device may be requested.\n  const adapter = await navigator.gpu.requestAdapter();\n  if (!adapter) {\n    console.error(\"No adapter\");\n    return null;\n  }\n\n  // Get the GPU device.\n  const device = await adapter.requestDevice();\n\n  // Handle disconnect from the GPU device.\n  device.lost.then((info) => {\n    console.error(`WebGPU device was lost: ${info.message}`);\n\n    // Reason will be 'destroyed' if we intentionally destroy the device.\n    if (info.reason !== \"destroyed\") {\n      // TODO: try again.\n      console.log(\"Can restart if we want\");\n    }\n  });\n\n  return device;\n}\n\nasync function run() {\n  const device = await getGPUDevice();\n\n  if (!device) {\n    console.log(\"Aborted due to null GPUDevice.\");\n    return;\n  }\n\n  // Buffers passed to GPU shader.\n  const rayBuffer = device.createBuffer({\n    size: RAY_BUFFER_SIZE,\n    usage:\n      GPUBufferUsage.STORAGE |\n      GPUBufferUsage.COPY_SRC |\n      GPUBufferUsage.COPY_DST,\n  });\n\n  const triangleBuffer = device.createBuffer({\n    size: TRIANGLE_BUFFER_SIZE,\n    usage:\n      GPUBufferUsage.STORAGE |\n      GPUBufferUsage.COPY_SRC |\n      GPUBufferUsage.COPY_DST,\n  });\n\n  const raycastResultBuffer = device.createBuffer({\n    size: RESULT_BUFFER_SIZE,\n    usage:\n      GPUBufferUsage.STORAGE |\n      GPUBufferUsage.COPY_SRC |\n      GPUBufferUsage.COPY_DST,\n  });\n\n  // Bind group layout and bind group define how the buffers are passed to the shader.\n  const bindGroupLayout = device.createBindGroupLayout({\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: { type: \"storage\" },\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: { type: \"storage\" },\n      },\n      {\n        binding: 2,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: { type: \"storage\" },\n      },\n    ],\n  });\n  const bindGroup = device.createBindGroup({\n    layout: bindGroupLayout,\n    entries: [\n      { binding: 0, resource: { buffer: rayBuffer } },\n      { binding: 1, resource: { buffer: triangleBuffer } },\n      { binding: 2, resource: { buffer: raycastResultBuffer } },\n    ],\n  });\n\n  // Create the GPU shader and compute pipeline.\n  const shaderModule = device.createShaderModule({\n    code: shader,\n  });\n  const computePipeline = device.createComputePipeline({\n    layout: device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    }),\n    compute: { module: shaderModule, entryPoint: \"main\" },\n  });\n\n  // Schedule copying data into buffers.\n  device.queue.writeBuffer(rayBuffer, 0, rayData);\n  device.queue.writeBuffer(triangleBuffer, 0, triangleData);\n\n  // Schedule the GPU shader pass.\n  const commandEncoder = device.createCommandEncoder();\n  const passEncoder = commandEncoder.beginComputePass();\n\n  passEncoder.setPipeline(computePipeline);\n  passEncoder.setBindGroup(0, bindGroup);\n\n  passEncoder.dispatchWorkgroups(Math.ceil(NUM_RAYS / WORKGROUP_SIZE));\n  passEncoder.end();\n\n  // Schedule copying output buffer to staging buffer.\n  const stagingBuffer = device.createBuffer({\n    size: RESULT_BUFFER_SIZE,\n    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n  });\n\n  commandEncoder.copyBufferToBuffer(\n    raycastResultBuffer,\n    0,\n    stagingBuffer,\n    0,\n    RESULT_BUFFER_SIZE, // Length, bytes.\n  );\n\n  console.time(\"run\");\n\n  // Execute the scheduled commands.\n  device.queue.submit([commandEncoder.finish()]);\n\n  // Map result buffer back to staging buffer (which can be read in JS).\n  await stagingBuffer.mapAsync(GPUMapMode.READ, 0, RESULT_BUFFER_SIZE);\n\n  console.timeEnd(\"run\");\n\n  // Get the data from the staging buffer.\n  const arrayDataOutput = stagingBuffer.getMappedRange().slice();\n  stagingBuffer.unmap();\n\n  // Convert to the correct type, and display the output.\n  const distances = new Float32Array(arrayDataOutput);\n  console.log(distances);\n}\n\nrun();\n"],
  "mappings": "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",
  "names": []
}
